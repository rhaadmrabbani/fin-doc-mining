# parse_sections.py
# Author(s): Rhaad M. Rabbani (2017)

# This file contains the section parser.



import re
from collections import defaultdict



from utils.utils import *
from utils.text_utils import *
from parse_pages import para_re



# The section parser extracts sections form a set of pages generated by the page parser.

def parse_sections( pages , debug = False ) :
    
    for page in pages : page.paras = split_paras( page.text )
    
    matches = [ ]
    
    for page_id , page in enumerate( pages ) :
        for para_id , para in enumerate( page.paras ) :
            text = tag_re.sub( '' , para )
            m = section_header0_re.search( text )
            if m and len( list( item_re.finditer( text ) ) ) <= 1 :
                body_para_id = None
                if m.group( 'item_num' ) :
                    body_para_id = para_id + ( 2
                                               if para_id + 1 < len( page.paras )
                                               and m.group( 'item_num' )
                                               and not ( m.group( 'title' ) and m.group( 'title' ).strip( ) )
                                               and title_re.search( tag_re.sub( '' , page.paras[ para_id + 1 ] ) )
                                               else 1 )
                matches.append( ( m , page_id , para_id , body_para_id ) )
    
    if debug :
        for m , page_id , para_id , body_para_id in matches :
            print page_id , ( pages[ page_id ].header_page_num , pages[ page_id ].footer_page_num ) , pages[ page_id ].paras[ para_id : body_para_id if body_para_id else para_id + 1 ]
    
    item_num_to_text_map = defaultdict( str )
    
    for m_id in range( len( matches ) - 1 ) :
        m1 , page_id1 , para_id1 , body_para_id1 = matches[ m_id ]
        m2 , page_id2 , para_id2 , body_para_id2 = matches[ m_id + 1 ]
        item_num = m1.group( 'item_num' )
        if item_num :
            item_num = item_num if not m1.group( 'bad_1' ) else '1' + item_num[ 1 : ]
            item_num = re.sub( r'[ \.]' , '' , item_num )
            item_num = item_num.upper( )
            if page_id1 == page_id2 : paras = pages[ page_id1 ].paras[ body_para_id1 : para_id2 ]
            else : paras = pages[ page_id1 ].paras[ body_para_id1 : ] + [ para for page in pages[ page_id1 + 1 : page_id2 ] for para in page.paras ] + pages[ page_id2 ].paras[ : para_id2 ]
            text = join_paras( paras )
            item_num_to_text_map[ item_num ] = ( item_num_to_text_map[ item_num ] + '\n\n' + text ).strip( '\n' )
            
    return item_num_to_text_map



section_header0_re = re.compile( '^\s*(item\s*(?P<item_num>((?P<bad_1>i)|\d)\d?[ \.]*[a-e]?)([-\.:\s]\s*(?P<title>.*))?\s*$|part +(?P<part_num>i[iv]*)|signatures)' , re.I | re.S )
item_re = re.compile( r'item' , re.I )
title_re = re.compile( r'^\s*[A-Z]\S*( +([A-Z]\S*|\S{1,5}))*\s*$' )



# MIT License
#
# Copyright (c) 2017 Rhaad M. Rabbani
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,  OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
